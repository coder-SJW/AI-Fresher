---
name: sjw-feature-design
description: 本技能用于根据需求分析文档进行功能设计，生成结构化的功能设计说明文档。当用户要求"进行功能设计"、"生成设计文档"、"基于需求文档设计功能"或需要功能编码实现指导时，使用此技能。此技能将需求分析转化为可实施的功能设计，包括模块设计、数据模型、API 接口和业务流程。
---

# SJW 功能设计

## 概述

本技能提供了一套系统化的功能设计工作流程，用于将需求分析文档转化为详细的功能设计说明文档。使用此技能可以生成包含功能模块设计、数据模型设计、API 接口设计和业务流程设计的完整技术方案，为后续的编码实现提供清晰的指导。

## 工作流程决策树

```
开始功能设计
    │
    ├─ 是否有需求分析文档？
    │   ├─ 是 → 基于需求文档进行设计
    │   └─ 否 → 先使用需求分析技能生成需求文档
    │
    ├─ 是否需要分析现有代码库？
    │   ├─ 是 → 探索现有架构和代码模式
    │   └─ 否 → 基于项目技术栈进行新设计
    │
    ├─ 设计重点
    │   ├─ 功能模块设计
    │   ├─ 数据模型设计
    │   ├─ API 接口设计
    │   └─ 业务流程设计
    │
    └─ 输出格式
        ├─ Markdown 设计文档（推荐）
        └─ 结构化设计规格说明
```

## 设计工作流程

### 步骤 1：需求分析与上下文理解

在开始设计之前，深入理解需求背景和项目上下文：

1. **需求文档分析**
   - 阅读需求分析文档，理解业务目标和功能范围
   - 识别核心功能模块和优先级
   - 理解非功能性需求（性能、安全、可扩展性等）

2. **项目上下文收集**
   - 如果是现有项目，探索当前代码架构
   - 了解现有技术栈和框架
   - 识别可复用的组件和模式
   - 了解现有的数据模型和 API 设计风格

3. **设计约束确认**
   - 技术约束（技术栈、框架版本、依赖限制）
   - 团队能力约束（熟悉的技术、开发资源）
   - 时间和预算约束
   - 兼容性要求（向后兼容、第三方系统集成）

### 步骤 2：功能模块设计

设计系统的功能架构和模块划分：

**模块划分原则：**
- 单一职责：每个模块只负责一个功能领域
- 高内聚低耦合：模块内部紧密相关，模块间依赖最小
- 可测试性：模块易于独立测试
- 可扩展性：支持未来功能扩展

**模块设计内容：**

对于每个功能模块，记录：

```markdown
### [模块名称]

**模块职责：**
- [核心职责 1]
- [核心职责 2]

**主要功能：**
1. [功能 1] - [功能描述]
2. [功能 2] - [功能描述]

**接口定义：**
- 对外接口：[公开的 API 或服务]
- 内部接口：[模块间的调用关系]

**依赖关系：**
- 依赖的其他模块：[模块列表]
- 被依赖的模块：[模块列表]

**设计模式：**
- 采用的设计模式：[模式名称]
- 设计理由：[为什么使用该模式]
```

**模块层次结构：**
```
应用层（Application Layer）
├── [模块 A]
├── [模块 B]
└── [模块 C]

领域层（Domain Layer）
├── [领域模型 A]
├── [领域模型 B]
└── [领域服务]

基础设施层（Infrastructure Layer）
├── [数据访问]
├── [外部服务集成]
└── [技术组件]
```

### 步骤 3：数据模型设计

设计系统的数据结构和数据关系：

**实体设计：**

对于每个核心实体，记录：

```markdown
### [实体名称]

**实体描述：** [实体的业务含义和用途]

**属性列表：**

| 字段名 | 类型 | 长度 | 必填 | 默认值 | 说明 |
|--------|------|------|------|--------|------|
| id | BIGINT | - | 是 | - | 主键 ID |
| name | VARCHAR | 255 | 是 | - | 名称 |
| created_at | TIMESTAMP | - | 是 | NOW() | 创建时间 |
| updated_at | TIMESTAMP | - | 是 | NOW() | 更新时间 |

**索引设计：**
- PRIMARY KEY: `id`
- UNIQUE INDEX: `uk_name` ON (`name`)
- NORMAL INDEX: `idx_created_at` ON (`created_at`)

**关系定义：**
- 一对一：[关系描述]
- 一对多：[关系描述，如：订单属于用户]
- 多对多：[关系描述及中间表]

**数据验证规则：**
- [业务规则 1]
- [业务规则 2]
```

**数据字典：**
维护完整的数据字典，包括：
- 所有表和字段的定义
- 字段类型和约束
- 枚举值的含义
- 数据的生命周期（软删除、归档策略）

**数据一致性保证：**
- 事务边界定义
- 并发控制策略（乐观锁/悲观锁）
- 分布式事务处理（如需要）
- 数据同步机制

### 步骤 4：API 接口设计

设计系统的 API 接口规范：

**RESTful API 设计规范：**

对于每个 API 端点，记录：

```markdown
### [API 名称]

**接口描述：** [API 的功能和用途]

**请求信息：**
- **方法：** POST /api/v1/resource
- **Content-Type：** application/json

**请求参数：**

| 参数名 | 类型 | 位置 | 必填 | 说明 |
|--------|------|------|------|------|
| id | path | - | 是 | 资源 ID |
| data | body | - | 是 | 请求数据 |

**请求示例：**
```json
{
  "name": "示例",
  "value": 123
}
```

**响应信息：**

**成功响应（200 OK）：**
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "id": 1,
    "name": "示例"
  }
}
```

**错误响应：**
- 400 Bad Request - 参数错误
- 401 Unauthorized - 未授权
- 404 Not Found - 资源不存在
- 500 Internal Server Error - 服务器错误

**业务错误码：**
- `10001` - [错误描述]
- `10002` - [错误描述]
```

**API 版本管理：**
- URL 版本：`/api/v1/`, `/api/v2/`
- Header 版本：`API-Version: 1.0`
- 向后兼容策略

**通用规范：**
- 命名约定（驼峰、下划线）
- 分页规范（page/size 或 cursor）
- 排序规范（sort_field, sort_order）
- 过滤规范（filter 条件）
- 时间格式（ISO 8601）

**安全考虑：**
- 身份认证（JWT、OAuth2）
- 权限控制（RBAC、ABAC）
- 请求签名
- 速率限制
- 敏感数据加密

### 步骤 5：业务流程设计

设计关键业务流程和状态机：

**业务流程图：**

使用文本或图表描述业务流程：

```markdown
### [业务流程名称]

**流程触发条件：** [何时触发此流程]

**流程步骤：**
1. [步骤 1] - [操作描述]
   - 输入：[输入数据]
   - 输出：[输出数据]
   - 异常处理：[异常情况处理方式]

2. [步骤 2] - [操作描述]
   - ...

**流程图：**
```
[开始] → [步骤 1] → [决策点]
                    ↓
              [是] → [步骤 2] → [步骤 3] → [结束]
              [否] → [异常处理] → [结束]
```

**参与者：**
- [角色 1] - [职责]
- [角色 2] - [职责]
```

**状态机设计：**

对于有状态的实体，设计状态转换：

```markdown
### [实体] 状态机

**状态定义：**
- `CREATED` - 已创建
- `PROCESSING` - 处理中
- `COMPLETED` - 已完成
- `FAILED` - 已失败
- `CANCELLED` - 已取消

**状态转换：**
```
CREATED → PROCESSING → COMPLETED
   ↓           ↓
CANCELLED   FAILED
```

**状态转换规则：**
- `CREATED` → `PROCESSING`：[触发条件和前置检查]
- `PROCESSING` → `COMPLETED`：[完成条件]
- `PROCESSING` → `FAILED`：[失败条件]
- `*` → `CANCELLED`：[取消条件和权限检查]

**状态相关操作：**
- 每个状态下允许的操作列表
- 状态变更的通知机制
```

**时序图：**

描述组件间的交互时序：

```markdown
### [场景] 时序图

**场景描述：** [场景的业务含义]

**参与者：**
- 用户
- API 网关
- 业务服务
- 数据库
- 外部服务

**时序：**
```
用户 → API 网关：发起请求
API 网关 → 业务服务：转发请求
业务服务 → 数据库：查询数据
数据库 --> 业务服务：返回数据
业务服务 --> API 网关：返回结果
API 网关 --> 用户：响应 200 OK
```
```

### 步骤 6：设计文档输出

生成结构化的功能设计文档：

```markdown
# [项目名称]功能设计文档

**文档版本：** 1.0
**最后更新：** [日期]
**作者：** AI 助手
**基于需求文档：** [需求文档版本]

## 文档变更历史

| 版本 | 日期 | 作者 | 变更说明 |
|------|------|------|----------|
| 1.0  | [日期] | AI 助手 | 初始版本 |

## 1. 设计概述

### 1.1 设计目标
[本设计文档要达成的目标]

### 1.2 设计范围
- 范围内：[包含的功能模块]
- 范围外：[不包含的内容]

### 1.3 技术栈
- 后端框架：[框架名称和版本]
- 数据库：[数据库类型和版本]
- 其他关键技术：[列表]

## 2. 功能模块设计

### 2.1 [模块 A]
[模块详细设计]

### 2.2 [模块 B]
[模块详细设计]

### 2.3 模块依赖关系图
[模块间的关系图]

## 3. 数据模型设计

### 3.1 实体关系图（ERD）
[实体关系描述]

### 3.2 数据表设计

#### 3.2.1 [表名 1]
[表的详细设计]

#### 3.2.2 [表名 2]
[表的详细设计]

### 3.3 数据字典
[完整的数据字典]

## 4. API 接口设计

### 4.1 API 设计规范
[命名、版本、安全等规范]

### 4.2 API 接口列表

#### 4.2.1 [模块 A] 接口
[模块的所有接口]

#### 4.2.2 [模块 B] 接口
[模块的所有接口]

### 4.3 错误码定义
[错误码列表和说明]

## 5. 业务流程设计

### 5.1 [核心流程 1]
[流程详细设计]

### 5.2 [核心流程 2]
[流程详细设计]

## 6. 非功能性设计

### 6.1 性能设计
- 性能目标：[具体指标]
- 优化策略：[缓存、异步处理等]

### 6.2 安全设计
- 认证授权：[方案]
- 数据加密：[方案]
- 安全防护：[防注入、XSS 等]

### 6.3 可扩展性设计
- 扩展点：[可扩展的功能点]
- 扩展机制：[如何扩展]

### 6.4 可维护性设计
- 日志规范：[日志级别和格式]
- 监控指标：[关键指标]
- 告警规则：[告警条件]

## 7. 技术实现要点

### 7.1 关键技术点
[关键技术实现方案]

### 7.2 技术难点和解决方案
[难点分析和解决方案]

### 7.3 代码组织结构
```
src/
├── controllers/    # 控制器
├── services/       # 业务逻辑
├── models/         # 数据模型
├── repositories/   # 数据访问
├── dto/            # 数据传输对象
├── exceptions/     # 异常定义
└── utils/          # 工具类
```

## 8. 测试策略

### 8.1 单元测试
- 测试框架：[框架名称]
- 覆盖率目标：[百分比]

### 8.2 集成测试
- 测试场景：[关键场景]

### 8.3 性能测试
- 测试工具：[工具名称]
- 性能指标：[具体指标]

## 9. 部署方案

### 9.1 部署架构
[部署环境架构图]

### 9.2 部署步骤
1. [步骤 1]
2. [步骤 2]

### 9.3 回滚方案
[如何回滚到上一版本]

## 10. 附录

### 10.1 术语表
| 术语 | 说明 |
|------|------|
| [术语] | [解释] |

### 10.2 参考资料
- [参考文档 1]
- [参考文档 2]
```

## 设计原则

**SOLID 原则：**
- **单一职责原则**：每个模块、类、函数只负责一件事
- **开闭原则**：对扩展开放，对修改封闭
- **里氏替换原则**：子类可以替换父类
- **接口隔离原则**：不应该依赖不需要的接口
- **依赖倒置原则**：依赖抽象而非具体实现

**DRY 原则（Don't Repeat Yourself）：**
- 避免代码重复
- 提取公共逻辑
- 使用抽象和泛化

**KISS 原则（Keep It Simple, Stupid）：**
- 保持设计简单
- 避免过度设计
- 优先选择简单方案

**YAGNI 原则（You Aren't Gonna Need It）：**
- 只设计当前需要的功能
- 不为未来可能的需求过度设计
- 保持架构的演进能力

## 最佳实践

**功能模块设计：**
- 优先考虑模块的独立性和可测试性
- 使用依赖注入降低耦合
- 定义清晰的模块接口和契约
- 考虑使用领域驱动设计（DDD）方法

**数据模型设计：**
- 数据库范式化（3NF），适度反范式化以优化性能
- 使用合适的数据类型和长度
- 合理使用索引，平衡查询性能和写入性能
- 考虑数据迁移和版本演进

**API 设计：**
- 遵循 RESTful 设计风格
- 使用标准 HTTP 方法（GET、POST、PUT、DELETE）
- 提供清晰的错误信息和错误码
- 考虑 API 的向后兼容性

**业务流程设计：**
- 识别核心业务流程和边缘情况
- 设计健壮的异常处理机制
- 考虑事务一致性和补偿机制
- 设计可观测的业务监控点

**常见设计陷阱：**
- 过度设计：为不存在的需求设计复杂架构
- 过早优化：在未明确性能瓶颈前优化
- 忽视边界情况：只考虑正常流程，不考虑异常
- 忽视可测试性：设计难以测试的耦合代码

## 设计检查清单

在完成功能设计后，验证：

- [ ] 设计覆盖所有需求文档中的功能点
- [ ] 模块划分清晰，职责明确
- [ ] 数据模型设计合理，关系清晰
- [ ] API 接口定义完整，符合规范
- [ ] 业务流程设计完整，考虑边界情况
- [ ] 非功能性需求（性能、安全、可扩展性）已考虑
- [ ] 设计遵循项目技术栈和规范
- [ ] 考虑了错误处理和异常情况
- [ ] 设计文档清晰、完整、可实施
- [ ] 有明确的实现路径和优先级
